// Package v1alpha1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package v1alpha1

import (
	"encoding/json"
	"fmt"
	"time"

	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ProviderStatus.
const (
	Registered ProviderStatus = "registered"
	Updated    ProviderStatus = "updated"
)

// Error RFC 7807 compliant error response
type Error struct {
	// Detail Human-readable explanation specific to this occurrence
	Detail *string `json:"detail,omitempty"`

	// Instance URI reference for this specific error occurrence
	Instance *string `json:"instance,omitempty"`

	// Status HTTP status code
	Status *int `json:"status,omitempty"`

	// Title Short human-readable summary of the problem
	Title string `json:"title"`

	// Type URI reference identifying the error type
	Type string `json:"type"`
}

// Health Health status singleton resource
type Health struct {
	// Path Canonical path of the resource
	Path *string `json:"path,omitempty"`

	// Status Health status
	Status *string `json:"status,omitempty"`
}

// Provider Full provider resource representation
type Provider struct {
	// CreateTime Timestamp when the provider was first registered
	CreateTime *time.Time `json:"create_time,omitempty"`

	// DisplayName Human-readable display name for the provider
	DisplayName *string `json:"display_name,omitempty"`

	// Endpoint Full endpoint URL where the provider API is accessible
	Endpoint string `json:"endpoint"`

	// HealthStatus Health status of the provider
	HealthStatus *string `json:"health_status,omitempty"`

	// Id Unique identifier for the Service Provider
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Metadata Additional metadata about the provider
	Metadata *ProviderMetadata `json:"metadata,omitempty"`

	// Name Unique name of the Service Provider
	Name string `json:"name"`

	// Operations List of operations supported for this service type
	Operations *[]string `json:"operations,omitempty"`

	// Path Resource path identifier
	Path *string `json:"path,omitempty"`

	// SchemaVersion Schema version of the service type the SP supports
	SchemaVersion string `json:"schema_version"`

	// ServiceType Type of service this provider offers
	ServiceType string `json:"service_type"`

	// Status Registration status
	Status *ProviderStatus `json:"status,omitempty"`

	// UpdateTime Timestamp when the provider was last updated
	UpdateTime *time.Time `json:"update_time,omitempty"`
}

// ProviderStatus Registration status
type ProviderStatus string

// ProviderList Paginated list of providers
type ProviderList struct {
	// NextPageToken Token for retrieving the next page of results
	NextPageToken *string     `json:"next_page_token,omitempty"`
	Providers     *[]Provider `json:"providers,omitempty"`
}

// ProviderMetadata Additional metadata about the provider
type ProviderMetadata struct {
	// RegionCode Geographic region code where the provider operates
	RegionCode *string `json:"region_code,omitempty"`

	// Resources Resource capacity information
	Resources *ResourceCapacity `json:"resources,omitempty"`

	// Status Current operational status of the provider
	Status *string `json:"status,omitempty"`

	// Zone Availability zone or datacenter identifier
	Zone                 *string                `json:"zone,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ResourceCapacity Resource capacity information
type ResourceCapacity struct {
	// TotalCpu Total CPU cores available
	TotalCpu *int `json:"total_cpu,omitempty"`

	// TotalMemory Total memory available
	TotalMemory *string `json:"total_memory,omitempty"`

	// TotalNode Total number of nodes
	TotalNode *int `json:"total_node,omitempty"`

	// TotalStorage Total storage available
	TotalStorage *string `json:"total_storage,omitempty"`
}

// ListProvidersParams defines parameters for ListProviders.
type ListProvidersParams struct {
	// Type Filter providers by service type
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// MaxPageSize Maximum number of results per page
	MaxPageSize *int `form:"max_page_size,omitempty" json:"max_page_size,omitempty"`

	// PageToken Token for pagination
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// CreateProviderParams defines parameters for CreateProvider.
type CreateProviderParams struct {
	// Id Optional provider ID for idempotent registration
	Id *openapi_types.UUID `form:"id,omitempty" json:"id,omitempty"`
}

// CreateProviderJSONRequestBody defines body for CreateProvider for application/json ContentType.
type CreateProviderJSONRequestBody = Provider

// ApplyProviderJSONRequestBody defines body for ApplyProvider for application/json ContentType.
type ApplyProviderJSONRequestBody = Provider

// Getter for additional properties for ProviderMetadata. Returns the specified
// element and whether it was found
func (a ProviderMetadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProviderMetadata
func (a *ProviderMetadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProviderMetadata to handle AdditionalProperties
func (a *ProviderMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["region_code"]; found {
		err = json.Unmarshal(raw, &a.RegionCode)
		if err != nil {
			return fmt.Errorf("error reading 'region_code': %w", err)
		}
		delete(object, "region_code")
	}

	if raw, found := object["resources"]; found {
		err = json.Unmarshal(raw, &a.Resources)
		if err != nil {
			return fmt.Errorf("error reading 'resources': %w", err)
		}
		delete(object, "resources")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["zone"]; found {
		err = json.Unmarshal(raw, &a.Zone)
		if err != nil {
			return fmt.Errorf("error reading 'zone': %w", err)
		}
		delete(object, "zone")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProviderMetadata to handle AdditionalProperties
func (a ProviderMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.RegionCode != nil {
		object["region_code"], err = json.Marshal(a.RegionCode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'region_code': %w", err)
		}
	}

	if a.Resources != nil {
		object["resources"], err = json.Marshal(a.Resources)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'resources': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	if a.Zone != nil {
		object["zone"], err = json.Marshal(a.Zone)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'zone': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
